§2 算法

定义：解决特定问题求解步骤的描述，在计算机中表现为指令的 有限序列，并且每条指令表示一个或多个操作。

特性：输入、输出、有穷性、确定性和可行性。

设计要求：正确性、可读性、健壮性、 时间效率高和存储量低

##算法效率度度量

事后统计方法:这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。（不科学、不准确）

事前分析估算方法:在计算机程序编制前，依据统计方法对算法进行估算。

函数渐进增长：给定两个函数 f(n)和 g(n)，如果存在一个整数 N， 使得对于所有的 n > N，f(n)总是比 g(n)大，那么，我们说 f(n) 的增长渐近快于 g(n)。

算法时间复杂度： 在进行算法分析时，语句总的执行次数 T(n)是关于问题规模 n 的函数，进而分析 T(n)随 n 的变化情况并确定 T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，大O记法记作:T(n) = O(f(n))。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复 杂度。其中 f(n)是问题规模 n 的某个函数。
比如：O(n)，O(1)，O(n2)。我们分别给它们取了非官方的名称，O(1)叫常数阶、O(n)叫线 性阶、O(n2)叫平方阶 T(n)= O(f(n))

推导大 O 阶:
1.用常数 1 取代运行时间中的所有加法常数。
2.在修改后的运行次数函数中，只保留最高阶项。
3.如果最高阶项存在且不是 1，则去除与这个项相乘的常数。 得到的结果就是大 O 阶。

eg1:
int i,j;
for(i = 0; i < m; i++)
{
    for (j=0;j<n;j++){ /*时间复杂度为 O(1)的程序步骤序列*/ }
}
T(n)=O(m*n)

eg2:
int i,j;
for(i = 0; i < n; i++)
{
    for (j=i;j<n;j++) {
        /*时间复杂度为 O(1)的程序步骤序列*/
    }
}

T(n)=O(n*n)

算法空间复杂度：通过计算算法所需的存储空间实现，算法空间复杂度的计算公 式记作:S(n)= O(f(n))，其中，n 为问题的规模，f(n)为语句关于 n 所占存储空间的函数。


趣题：
CPU在短短几年间，速度提高了 100 倍，这其实已经很夸张了。(n)的程序，却写出了O(n2)的程序，仅仅因为容易想到，也容易写。即在O(n2)的时间复杂度算法程序下，速度其实只提高了 10 倍
，而对于O(n)时间复杂度的算法来说，那才是真的 100 倍。
也就是说，一台老式CPU的计算机运行O(n)的程序和一台速度提高 100 倍新式CPU 运行O(n2)的程序。最终效率高的胜利方却是老式CPU的计算机，原因就在于算法的优 劣直接决定了程序运行的效率



§3 线性表

定义：零个或多个数据元素的有限序列（相同类型的数据）

顺序存储结构：用一段地址连续的存储单元依次存储线性表的数据元素
    三属性：存储空间的起始位置：数组data的存储位置就是存储空间的存储位置；
           线性表的最大存储容量：数组长度的MaxSize;
           线性表的当前长度：length



